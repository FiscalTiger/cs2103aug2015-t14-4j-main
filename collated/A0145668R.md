# A0145668R
###### src\easycheck\commandParser\CommandParser.java
``` java
    private Command createAddCommand(String[] arguments) {
        Add cmd = null;
        String taskName;
        DateTime start;
        DateTime end;
        DateTime[] parsedDates;
        try {

            if (arguments.length == ADD_ARGS_NUM_FLOATING) {
                taskName = arguments[0];
                cmd = new Add(taskName);
            } else if (arguments.length == ADD_ARGS_NUM_EVENT_WITH_DATES) {
                taskName = arguments[0];
                parsedDates = parseDateText(arguments[1]);
                if (parsedDates.length == 1) {
                    end = parsedDates[PARSED_DATE_TEXT_FIRST];
                    if (end != null) {
                        cmd = new Add(taskName, end);
                    } else {
                        return new Invalid(String.format(
                                MESSAGE_INVALID_ADD_DATE, arguments[1]));
                    }
                } else if (parsedDates.length == 2) {
                    start = parsedDates[PARSED_DATE_TEXT_FIRST];
                    end = parsedDates[PARSED_DATE_TEXT_SECOND];
                    if (start != null && end != null) {
                        cmd = new Add(taskName, start, end);
                    } else {
                        return new Invalid(String.format(
                                MESSAGE_INVALID_ADD_DATE, arguments[1]));

                    }
                } else {
                    return new Invalid(MESSAGE_INVALID_ADD_DATES);
                }
            } else if (arguments.length == ADD_ARGS_NUM_REPEATING_EVENT_WITHOUT_STOP) {
                String frequency = arguments[2];
                taskName = arguments[0];
                parsedDates = parseDateText(arguments[1]);
                if (parsedDates.length == 1) {
                    end = parsedDates[PARSED_DATE_TEXT_FIRST];
                    if (end != null) {
                        cmd = new Add(taskName, end);
                    } else {
                        return new Invalid(String.format(
                                MESSAGE_INVALID_ADD_DATE, arguments[1]));
                    }
                } else if (parsedDates.length == 2) {
                    start = parsedDates[PARSED_DATE_TEXT_FIRST];
                    end = parsedDates[PARSED_DATE_TEXT_SECOND];
                    if (start != null && end != null) {
                        cmd = new Add(taskName, start, end);
                    } else {
                        return new Invalid(String.format(
                                MESSAGE_INVALID_ADD_DATE, arguments[1]));
                    }
                } else {
                    return new Invalid(MESSAGE_INVALID_ADD_DATES);
                }

                cmd.setRepeating(REPEATING);

                if (Add.isValidFrequency(frequency)) {
                    cmd.setFrequency(frequency);
                } else {
                    return new Invalid(MESSAGE_INVALID_ADD_FREQUENCY);
                }
            } else if (arguments.length == 4) {
                String frequency = arguments[2];
                DateTime stopDate = parseDateText(arguments[3])[PARSED_DATE_TEXT_FIRST];
                if (stopDate == null) {
                    return new Invalid(String.format(MESSAGE_INVALID_ADD_DATE,
                            arguments[3]));
                }
                taskName = arguments[0];
                parsedDates = parseDateText(arguments[1]);
                if (parsedDates.length == 1) {
                    end = parsedDates[PARSED_DATE_TEXT_FIRST];
                    if (end != null) {
                        cmd = new Add(taskName, end);
                    } else {
                        return new Invalid(String.format(
                                MESSAGE_INVALID_ADD_DATE, arguments[1]));
                    }
                } else if (parsedDates.length == 2) {
                    start = parsedDates[PARSED_DATE_TEXT_FIRST];
                    end = parsedDates[PARSED_DATE_TEXT_SECOND];
                    if (start != null && end != null) {
                        cmd = new Add(taskName, start, end);
                    } else {
                        return new Invalid(String.format(
                                MESSAGE_INVALID_ADD_DATE, arguments[1]));
                    }
                } else {
                    return new Invalid(MESSAGE_INVALID_ADD_DATES);
                }

                cmd.setRepeating(REPEATING);
                cmd.setStopDate(stopDate);

                if (Add.isValidFrequency(frequency)) {
                    cmd.setFrequency(frequency);
                } else {
                    return new Invalid(MESSAGE_INVALID_ADD_FREQUENCY);
                }
            }
        } catch (Exception e) {
            return new Invalid(String.format(MESSAGE_INVALID_ADD_DATE,
                    arguments[1]));
        }
        assert (cmd != null);

        return cmd;
    }

    private String[] getArgumentsRepeat(String commandArguments) {
        // split arguments and then trim them.
        String[] arguments = trimArguments(commandArguments
                .split(ARGUMENT_SPLITTER));
        return arguments;
    }

```
###### src\easycheck\commandParser\CommandParser.java
``` java
    private String[] getDisplayArguments(String commandArguments) {
        // split arguments and then trim them.
        String[] arguments = trimArguments(commandArguments
                .split(ARGUMENT_SPLITTER));
        return arguments;
    }

```
###### src\easycheck\commandParser\CommandParser.java
``` java
    private Command createDisplayCommand(String[] arguments) {
        Display disp = new Display();
        try {
            if (arguments == null) {
                disp.setDefaultFlag(true);
            } else if (arguments.length == 1) {
                if (arguments[0].equals(DISPLAY_FLAG_FLOATING)) {
                    disp.setFloatingFlag(true);
                } else if (arguments[0].equals(DISPLAY_FLAG_OVER_DUE)) {
                    disp.setOverDueFlag(true);
                } else if (arguments[0].equals(DISPLAY_FLAG_DONE)) {
                    disp.setDoneFlag(true);
                } else if (arguments[0].equals(DISPLAY_FLAG_ALL)) {
                    disp.setAllFlag(true);
                } else {
                    return new Invalid(String.format(
                            MESSAGE_INVALID_DISPLAY_ARGS, arguments[0]));
                }
            } else if (arguments.length == 2) {
                if (arguments[0].equals(DISPLAY_FLAG_DATE)) {
                    DateTime displayDate = parseDateText(arguments[1])[PARSED_DATE_TEXT_FIRST];
                    if (displayDate != null) {
                        disp.setDateFlag(true);
                        disp.setDisplayDate(displayDate);
                    } else {
                        return new Invalid(String.format(
                                MESSAGE_INVALID_DISPLAY_DATE, arguments[1]));
                    }
                } else if (arguments[0].equals(DISPLAY_FLAG_INDEX)) {
                    try {
                        int eventIndex = Integer.parseInt(arguments[1]);
                        disp.setEventIndex(eventIndex);
                        disp.setIndexFlag(true);
                    } catch (NumberFormatException e) {
                        return new Invalid(String.format(
                                MESSAGE_INVALID_DISPLAY_INDEX, arguments[1]));
                    }
                } else {
                    return new Invalid(String.format(
                            MESSAGE_INVALID_DISPLAY_ARGS, arguments[0]));
                }
            } else {
                return new Invalid(MESSAGE_INVALID_DISPLAY_NUM_OF_ARGS);
            }
        } catch (Exception e) {
            return new Invalid(MESSAGE_INVALID_DISPLAY_NUM_OF_ARGS);
        }
        return disp;
    }

```
###### src\easycheck\commandParser\CommandParser.java
``` java
    private Command createRepeatCommand(String[] arguments) {
        if (!Repeat.isValidFrequency(arguments[REPEAT_ARGS_FREQUENCY])) {
            return new Invalid(MESSAGE_INVALID_REPEAT_FREQUENCY);
        }

        if (arguments.length == 2) {
            return new Repeat(arguments[REPEAT_ARGS_EVENT],
                    arguments[REPEAT_ARGS_FREQUENCY]);
        } else if (arguments.length == 3) {
            DateTime stop;
            try {
                stop = parseDateText(arguments[REPEAT_ARGS_STOP])[PARSED_DATE_TEXT_FIRST];
                return new Repeat(arguments[REPEAT_ARGS_EVENT],
                        arguments[REPEAT_ARGS_FREQUENCY], stop);
            } catch (Exception e) {
                return new Invalid(String.format(MESSAGE_INVALID_REPEAT_DATE,
                        arguments[REPEAT_ARGS_STOP]));
            }

        } else {
            return new Invalid(MESSAGE_INVALID_REPEAT_NUM_OF_ARGS);
        }
    }

```
###### src\easycheck\commandParser\CommandParser.java
``` java
    public DateTime[] parseDateText(String dateString) throws Exception {
        isValidExplicitDate(dateString);
        Parser dateParser = new Parser();
        DateTime[] parsedDates;
        List<DateGroup> dateGroups = dateParser.parse(dateString);
        if (dateGroups.size() == 1) {
            DateGroup dateGroup = dateGroups.get(0);
            if (dateGroup.getDates().size() == 1) {
                parsedDates = new DateTime[DATE_GROUP_ONE_DATE];
                parsedDates[0] = new DateTime(dateGroup.getDates().get(0));
            } else if (dateGroup.getDates().size() == 2) {
                parsedDates = new DateTime[DATE_GROUP_TWO_DATE];
                parsedDates[0] = new DateTime(dateGroup.getDates().get(0));
                parsedDates[1] = new DateTime(dateGroup.getDates().get(1));
            } else {
                parsedDates = new DateTime[DATE_GROUP_ONE_DATE];
                parsedDates[0] = null;
            }

        } else {
            parsedDates = new DateTime[DATE_GROUP_ONE_DATE];
            parsedDates[0] = null;
        }
        return parsedDates;
    }

```
###### src\easycheck\commandParser\CommandTypes\Add.java
``` java
	private static final String REPEATING_DAILY = "daily";
	private static final String REPEATING_WEEKLY = "weekly";
	private static final String REPEATING_BIWEEKLY = "biweekly";
	private static final String REPEATING_MONTHLY = "monthly";
	private static final String REPEATING_YEARLY = "yearly";
	
	private String taskName; 
	private DateTime start;
	private DateTime end;
	private boolean isRepeating = false;
	private String frequency = null;
    private DateTime stopDate = null;
    
```
###### src\easycheck\commandParser\CommandTypes\Add.java
``` java
	public Add(String taskName) {
		this.setTaskName(taskName);
	};
	
```
###### src\easycheck\commandParser\CommandTypes\Add.java
``` java
	public Add(String taskName, DateTime deadline) {
		this.setTaskName(taskName);
		this.setEnd(deadline);
	}

```
###### src\easycheck\commandParser\CommandTypes\Add.java
``` java
	public Add(String taskName, DateTime start, DateTime end) {
		this.setTaskName(taskName);
		this.setStart(start);
		this.setEnd(end);
	}
	
```
###### src\easycheck\commandParser\CommandTypes\Add.java
``` java
	public void setTaskName(String taskName) {
		this.taskName = taskName;
	}
	
```
###### src\easycheck\commandParser\CommandTypes\Add.java
``` java
	public String getTaskName(){
		return taskName;
	}
	
	/**
	 * Returns whether or not the add command contains
	 * a start date
	 * @return true if start exists
```
###### src\easycheck\commandParser\CommandTypes\Add.java
``` java
	 */
	public boolean hasStart() {
		return !(start == null);
	}
	
```
###### src\easycheck\commandParser\CommandTypes\Add.java
``` java
	public DateTime getStart(){
		return start;
	}
	
```
###### src\easycheck\commandParser\CommandTypes\Add.java
``` java
	public void setStart(DateTime start) {
		this.start = start;
	}
	
	/**
	 * Returns whether or not the add command contains
	 * an end date
	 * @return true if end exists
```
###### src\easycheck\commandParser\CommandTypes\Add.java
``` java
	 */
	public boolean hasEnd() {
		return !(end == null);
	}
	
```
###### src\easycheck\commandParser\CommandTypes\Add.java
``` java
	public DateTime getEnd(){
		return end;
	}
	
```
###### src\easycheck\commandParser\CommandTypes\Add.java
``` java
	public void setEnd(DateTime end) {
		this.end = end;
	}

```
###### src\easycheck\commandParser\CommandTypes\Add.java
``` java
	public boolean isRepeating() {
		return isRepeating;
	}

```
###### src\easycheck\commandParser\CommandTypes\Add.java
``` java
	public void setRepeating(boolean isRepeating) {
		this.isRepeating = isRepeating;
	}
	
```
###### src\easycheck\commandParser\CommandTypes\Add.java
``` java
    public boolean hasStopDate() {
    	return stopDate != null;
    }

```
###### src\easycheck\commandParser\CommandTypes\Add.java
``` java
	public DateTime getStopDate() {
		return stopDate;
	}

```
###### src\easycheck\commandParser\CommandTypes\Add.java
``` java
	public void setStopDate(DateTime stopDate) {
		this.stopDate = stopDate;
	}
	
```
###### src\easycheck\commandParser\CommandTypes\Add.java
``` java
	public static boolean isValidFrequency(String frequency) {
		if(frequency.equals(REPEATING_DAILY) || frequency.equals(REPEATING_WEEKLY) ||
				frequency.equals(REPEATING_BIWEEKLY) || frequency.equals(REPEATING_MONTHLY) ||
				frequency.equals(REPEATING_YEARLY)) {
			return true;
		} else {
			return false;
		}
	}

```
###### src\easycheck\commandParser\CommandTypes\Add.java
``` java
	public String getFrequency() {
		return frequency;
	}
	
```
###### src\easycheck\commandParser\CommandTypes\Add.java
``` java
	public void setFrequency(String frequency) {
		this.frequency = frequency;
	}
	
	public String toString() {
		return "Event: " + this.taskName + 
				" Start: " + this.start + 
				" End: " + this.end + 
				" Repeating: " + this.isRepeating + 
				" freqency: " + this.frequency + 
				" Stop Date: " +this.stopDate;
	}
```
###### src\easycheck\commandParser\CommandTypes\Display.java
``` java
 */

public class Display extends Command {
	private static final String DATE_OUTPUT_FORMAT = "%s %d %s %d";

	private boolean dateFlag = false;
	private boolean floatingFlag = false;
	private boolean defaultFlag = false;
	private boolean indexFlag = false;
	private boolean overDueFlag = false;
	private boolean doneFlag = false;
	private boolean allFlag = false;
	
	private int eventIndex;
	private DateTime displayDate;
	
	
	public Display() {}
	
	public boolean isDate() {
		return dateFlag;
	}

	public void setDateFlag(boolean dateFlag) {
		this.dateFlag = dateFlag;
	}

	public boolean isFloating() {
		return floatingFlag;
	}

	public void setFloatingFlag(boolean floatingFlag) {
		this.floatingFlag = floatingFlag;
	}

	public boolean isDefault() {
		return defaultFlag;
	}

	public void setDefaultFlag(boolean defaultFlag) {
		this.defaultFlag = defaultFlag;
	}

	public boolean isIndex() {
		return indexFlag;
	}

	public void setIndexFlag(boolean indexFlag) {
		this.indexFlag = indexFlag;
	}

	public boolean isOverDue() {
		return overDueFlag;
	}

	public void setOverDueFlag(boolean overDueFlag) {
		this.overDueFlag = overDueFlag;
	}

	public boolean isDone() {
		return doneFlag;
	}

	public void setDoneFlag(boolean doneFlag) {
		this.doneFlag = doneFlag;
	}

	public int getEventIndex() {
		return eventIndex;
	}

	public void setEventIndex(int eventIndex) {
		this.eventIndex = eventIndex;
	}

	public String getDisplayDate() {
		DateTime.Property pDayOfTheWeek = displayDate.dayOfWeek();
		DateTime.Property pMonthOfYear = displayDate.monthOfYear();
		String dateString = String.format(DATE_OUTPUT_FORMAT, pDayOfTheWeek.getAsShortText(),
				displayDate.getDayOfMonth(), pMonthOfYear.getAsShortText(), displayDate.getYear());
		return dateString;
	}

	public void setDisplayDate(DateTime displayDate) {
		this.displayDate = displayDate;
	}

	public boolean isAllFlag() {
		return allFlag;
	}

	public void setAllFlag(boolean allFlag) {
		this.allFlag = allFlag;
	}
```
###### src\easycheck\commandParser\CommandTypes\Repeat.java
``` java
	private static final String REPEATING_NONE = "none";
	private static final String REPEATING_DAILY = "daily";
	private static final String REPEATING_WEEKLY = "weekly";
	private static final String REPEATING_BIWEEKLY = "biweekly";
	private static final String REPEATING_MONTHLY = "monthly";
	private static final String REPEATING_YEARLY = "yearly";
	
    private String task;
    private String frequency;
    private DateTime endDate;

    public Repeat(String task, String frequency) {
    	this(task, frequency, null);
    }
    
    public Repeat(String task, String frequency, DateTime endDate) {
    	this.setTask(task);
    	this.setFrequency(frequency);
    	this.setEndDate(endDate);
    }
  

	public String getTask() {
		return task;
	}

	public void setTask(String task) {
		this.task = task;
	}

	public String getFrequency() {
		return frequency;
	}

	public void setFrequency(String frequency) {
		this.frequency = frequency;
	}

	public DateTime getEndDate() {
		return endDate;
	}

	public void setEndDate(DateTime endDate) {
		this.endDate = endDate;
	}
	
	public static boolean isValidFrequency(String frequency) {
		if(frequency.equals(REPEATING_DAILY) || frequency.equals(REPEATING_WEEKLY) ||
				frequency.equals(REPEATING_BIWEEKLY) || frequency.equals(REPEATING_MONTHLY) ||
				frequency.equals(REPEATING_YEARLY) || frequency.equals("none")) {
			return true;
		} else {
			return false;
		}
	}
```
###### src\easycheck\eventlist\CalendarEvent.java
``` java
 */

import java.io.IOException;
import java.io.StringWriter;
import java.util.LinkedHashMap;
import java.util.Map;

import org.joda.time.DateTime;
import org.joda.time.Duration;
import org.joda.time.format.DateTimeFormat;
import org.joda.time.format.DateTimeFormatter;
import org.json.simple.JSONObject;
import org.json.simple.JSONValue;

public class CalendarEvent extends Event {
	private static final String DATE_AND_TIME_OUTPUT_FORMAT = "%s %d %s %d at %02d:%02d";
	private static final String DATE_OUTPUT_FORMAT = "%s %d %s %d";
	private static final String TIME_OUTPUT_FORMAT = "%02d:%02d";
	private static final String DATE_AND_TIME_INPUT_FORMAT = "dd.MM.yyyy HH:mm";
	private static final String MESSAGE_JSON_STRING_ERROR = "Error in toJsonString method, most likely coding error";
	private static final String MESSAGE_TO_STRING_TEMPLATE = "@|yellow %d. %s from %s to %s%s|@\n";
	private static final String MESSAGE_TO_PRINT_GROUP_STRING_TEMPLATE = "@|yellow %d. %s from %s to %s%s|@\n";
	private static final String MESSAGE_REPEATING_ADDITION = " (Repeats %s)";
	
	private static final String REPEATING_DAILY = "daily";
	private static final String REPEATING_WEEKLY = "weekly";
	private static final String REPEATING_BIWEEKLY = "biweekly";
	private static final String REPEATING_MONTHLY = "monthly";
	private static final String REPEATING_YEARLY = "yearly";
	
	private static final String JSON_TYPE = "type";
	private static final String JSON_EVENT_INDEX = "index";
	private static final String JSON_EVENT_NAME = "name";
	private static final String JSON_START_DATE = "start";
	private static final String JSON_END_DATE = "end";
	private static final String JSON_REPEAT = "repeating";
	private static final String JSON_FREQUENCY = "frequency";
	private static final String JSON_STOPDATE = "stopdate";
	
	private static DateTimeFormatter fmt = DateTimeFormat.forPattern(DATE_AND_TIME_INPUT_FORMAT);
	private DateTime startDateAndTime;
	private DateTime endDateAndTime;
	private DateTime stopDate;
	private boolean repeating;
	private String frequency;
	
	public CalendarEvent(int eventIndex, String eventName, DateTime startDateAndTime, DateTime endDateAndTime) {
		this.setEventIndex(eventIndex);
		this.setEventName(eventName);
		this.startDateAndTime = startDateAndTime;
		this.endDateAndTime = endDateAndTime;
		this.setRepeating(false);
		this.setFrequency(null);
		this.setStopDate(null);
	}
	
	public CalendarEvent(CalendarEvent e) {
		this.setEventIndex(e.getEventIndex());
		this.setEventName(e.getEventName());
		this.setStartDateAndTime(e.getStartDateAndTime());
		this.setEndDateAndTime(e.getEndDateAndTime());
		this.setRepeating(e.isRepeating());
		this.setFrequency(e.getFrequency());
		this.stopDate = e.stopDate;
	}
	
	public CalendarEvent(int eventIndex, String eventName, DateTime startDateAndTime, DateTime endDateAndTime,
			boolean repeating, String frequency) {
		this.setEventIndex(eventIndex);
		this.setEventName(eventName);
		this.startDateAndTime = startDateAndTime;
		this.endDateAndTime = endDateAndTime;
		this.setRepeating(repeating);
		this.setFrequency(frequency);
		this.setStopDate(null);
	}
	
	public CalendarEvent(int eventIndex, String eventName, DateTime startDateAndTime, DateTime endDateAndTime,
			boolean repeating, String frequency, DateTime stopDate) {
		this.setEventIndex(eventIndex);
		this.setEventName(eventName);
		this.startDateAndTime = startDateAndTime;
		this.endDateAndTime = endDateAndTime;
		this.setRepeating(repeating);
		this.setFrequency(frequency);
		this.setStopDate(stopDate);
	}
	
	public CalendarEvent(JSONObject jsonObj) {
		Long eventIndex = (Long) jsonObj.get(JSON_EVENT_INDEX);
		String eventName = (String) jsonObj.get(JSON_EVENT_NAME);
		startDateAndTime = fmt.parseDateTime((String)jsonObj.get(JSON_START_DATE));
		endDateAndTime = fmt.parseDateTime((String)jsonObj.get(JSON_END_DATE));
		repeating = ((Boolean)jsonObj.get(JSON_REPEAT)).booleanValue();
		
		if(repeating) {
			if(jsonObj.get(JSON_STOPDATE) != null) {
				stopDate = fmt.parseDateTime((String)jsonObj.get(JSON_STOPDATE));
			} else {
				stopDate = (DateTime)jsonObj.get(JSON_STOPDATE);
			}
			frequency = (String) jsonObj.get(JSON_FREQUENCY);
		}
		
		this.setEventIndex(eventIndex.intValue());
		this.setEventName(eventName);
	}
	
	/**
	 * Returns the start date and time of this event
	 * @return DateTime startDateAndTime
	 */
	public DateTime getStartDateAndTime() {
		if(this.isRepeating() && !this.isUpdated()) {
			update();
		}
		return startDateAndTime;
	}
	
	/**
	 * Returns the end date and time of this event
	 * @return DateTime endDateAndTime
	 */
	public DateTime getEndDateAndTime() {
		if(this.isRepeating() && !this.isUpdated()) {
			update();
		}
		return endDateAndTime;
	}
	
	public Duration getDuration() {
		return new Duration(startDateAndTime, endDateAndTime);
	}
	
	public String getStartDate() {
		DateTime.Property pDayOfTheWeek = getStartDateAndTime().dayOfWeek();
		DateTime.Property pMonthOfYear = getStartDateAndTime().monthOfYear();
		String dateString = String.format(DATE_OUTPUT_FORMAT, pDayOfTheWeek.getAsShortText(),
				getStartDateAndTime().getDayOfMonth(), pMonthOfYear.getAsShortText(), getStartDateAndTime().getYear());
		return dateString;
	}
	
	public String getStartTime() {
		String timeString = String.format(TIME_OUTPUT_FORMAT, getStartDateAndTime().getHourOfDay(), getStartDateAndTime().getMinuteOfHour());
		return timeString;
	}
	
	public String getEndDate() {
		DateTime.Property pDayOfTheWeek = getEndDateAndTime().dayOfWeek();
		DateTime.Property pMonthOfYear = getEndDateAndTime().monthOfYear();
		String dateString = String.format(DATE_OUTPUT_FORMAT, pDayOfTheWeek.getAsShortText(),
				getEndDateAndTime().getDayOfMonth(), pMonthOfYear.getAsShortText(), getEndDateAndTime().getYear());
		return dateString;
	}
	
	public String getEndTime() {
		String timeString = String.format(TIME_OUTPUT_FORMAT, getEndDateAndTime().getHourOfDay(), getEndDateAndTime().getMinuteOfHour());
		return timeString;
	}
	
	/**
	 * Sets a new start date and time
	 * @param newDateString in format of "E MM.dd.yyyy 'at' hh:mm:ss a zzz"
	 * See Documentation for java.text.SimpleDateFormat
	 */
	public void setStartDateAndTime(DateTime newDate) {
		// If end date is not set yet we can't assert
		// this is true but the other assert in
		// setEndDateAndTime will pick it up
		if(endDateAndTime != null) {
			assert(newDate.isBefore(endDateAndTime));
		}
		startDateAndTime = newDate;
	}
	
	/**
	 * Sets a new end date and time
	 * @param newDateString in format of "E MM.dd.yyyy 'at' hh:mm:ss a zzz"
	 * See Documentation for java.text.SimpleDateFormat
	 */
	public void setEndDateAndTime(DateTime newDate) {
		assert(startDateAndTime.isBefore(newDate));
		endDateAndTime = newDate;
	}
	
	public boolean isSameDay() {
		return this.getStartDate().equals(this.getEndDate());
	}
	
	public boolean isSameStartDay(DateTime date){
		DateTime.Property pDayOfTheWeek = date.dayOfWeek();
		DateTime.Property pMonthOfYear = date.monthOfYear();
		String dateString = String.format(DATE_OUTPUT_FORMAT, pDayOfTheWeek.getAsShortText(),
				date.getDayOfMonth(), pMonthOfYear.getAsShortText(), date.getYear());
		return dateString.equals(getStartDate());
	}
	
	public boolean isSameEndDay(DateTime date){
		DateTime.Property pDayOfTheWeek = date.dayOfWeek();
		DateTime.Property pMonthOfYear = date.monthOfYear();
		String dateString = String.format(DATE_OUTPUT_FORMAT, pDayOfTheWeek.getAsShortText(),
				date.getDayOfMonth(), pMonthOfYear.getAsShortText(), date.getYear());
		return dateString.equals(getEndDate());
	}
	
	public boolean isDone() {
		if(hasStopDate()) {
			if(repeating && !isUpdated()) {
				update();
			}
			return stopDate.isBefore(endDateAndTime);
		}
		return getEndDateAndTime().isBeforeNow();
	}
	
	private void update() {
		switch(frequency) {
			case REPEATING_DAILY:
				startDateAndTime = startDateAndTime.plusDays(1);
				endDateAndTime = endDateAndTime.plusDays(1);
				break;
			case REPEATING_WEEKLY:
				startDateAndTime = startDateAndTime.plusWeeks(1);
				endDateAndTime = endDateAndTime.plusWeeks(1);
				break;
			case REPEATING_BIWEEKLY:
				startDateAndTime = startDateAndTime.plusWeeks(2);
				endDateAndTime = endDateAndTime.plusWeeks(2);
				break;
			case REPEATING_MONTHLY:
				startDateAndTime = startDateAndTime.plusMonths(1);
				endDateAndTime = endDateAndTime.plusMonths(1);
				break;
			case REPEATING_YEARLY:
				startDateAndTime = startDateAndTime.plusYears(1);
				endDateAndTime = endDateAndTime.plusYears(1);
				break;
			default:
				try {
					throw new Exception("Got to defualt case in update. Something is wrong!");
				} catch (Exception e) {
					System.out.println(e.getMessage());
				}
		}
	}

	public boolean isUpdated() {
		return endDateAndTime.isAfterNow();
	}
	
	/**
	 * Returns the string form of this calendar event
	 */
	public String toString() {
		String startDateString = getFormattedStartDateString();
		String endDateString = getFormattedEndDateString();
		String repeatAddition = "";
		
		if(repeating) {
			repeatAddition = String.format(MESSAGE_REPEATING_ADDITION, frequency);
		}
		return String.format(
				MESSAGE_TO_STRING_TEMPLATE, this.getEventIndex(), this.getEventName(), 
				startDateString, endDateString, repeatAddition);
	}
	
	public String toPrintGroupString() {
		String repeatAddition = "";
		
		if(repeating) {
			repeatAddition = String.format(MESSAGE_REPEATING_ADDITION, frequency);
		}
		if (this.isSameDay()) {
			return String.format(MESSAGE_TO_PRINT_GROUP_STRING_TEMPLATE, this.getEventIndex(), 
					this.getEventName(), this.getStartTime(), this.getEndTime(), repeatAddition);
		} else {
			return String.format(MESSAGE_TO_PRINT_GROUP_STRING_TEMPLATE, this.getEventIndex(), 
					this.getEventName(), this.getStartTime(), this.getFormattedEndDateString(), repeatAddition);
		}
	}

	private String getFormattedStartDateString() {
		DateTime.Property pDayOfTheWeek = getStartDateAndTime().dayOfWeek();
		DateTime.Property pMonthOfYear = getStartDateAndTime().monthOfYear();
		return String.format(DATE_AND_TIME_OUTPUT_FORMAT, pDayOfTheWeek.getAsShortText(),
				getStartDateAndTime().getDayOfMonth(), pMonthOfYear.getAsShortText(), getStartDateAndTime().getYear(),
				getStartDateAndTime().getHourOfDay(), getStartDateAndTime().getMinuteOfHour());
	}
	
	private String getFormattedEndDateString() {
		DateTime.Property pDayOfTheWeek = getEndDateAndTime().dayOfWeek();
		DateTime.Property pMonthOfYear = getEndDateAndTime().monthOfYear();
		return String.format(DATE_AND_TIME_OUTPUT_FORMAT, pDayOfTheWeek.getAsShortText(),
				getEndDateAndTime().getDayOfMonth(), pMonthOfYear.getAsShortText(), getEndDateAndTime().getYear(),
				getEndDateAndTime().getHourOfDay(), getEndDateAndTime().getMinuteOfHour());
	}
	
	/**
	 * Returns the JSON string to write to the file for this calendar object
	 * @return jsonString
	 */
	public String toJsonString() {
		Map<String, Object> obj = new LinkedHashMap<String, Object>();
		obj.put(JSON_TYPE, "calendar");
		obj.put(JSON_EVENT_INDEX, new Integer(this.getEventIndex()));
		obj.put(JSON_EVENT_NAME, this.getEventName());
		obj.put(JSON_START_DATE, fmt.print(getStartDateAndTime()));
		obj.put(JSON_END_DATE, fmt.print(getEndDateAndTime()));
		obj.put(JSON_REPEAT, new Boolean(repeating));
		if(repeating) {
			obj.put(JSON_FREQUENCY, frequency);
			if(hasStopDate()) {
				obj.put(JSON_STOPDATE, fmt.print(stopDate));
			} else {
				obj.put(JSON_STOPDATE, null);
			}
		}
		
		StringWriter out = new StringWriter();
	    try {
			JSONValue.writeJSONString(obj, out);
		} catch (IOException e) {
			System.out.println(MESSAGE_JSON_STRING_ERROR);
		}
	    return out.toString();
	}
	
	// TODO override equals method
	public boolean equals(Object obj) {
		if (!(obj instanceof CalendarEvent)) {
			return false;
		} else {
			CalendarEvent e = (CalendarEvent) obj;
			return this.getEventIndex() == e.getEventIndex() && this.getEventName().equals(e.getEventName()) &&
					this.getStartDateAndTime().equals(e.getStartDateAndTime()) && 
					this.endDateAndTime.equals(e.getEndDateAndTime());
		}
	}
	
	/**
	 * Used to compare to Event subclasses
	 * @return int
	 */
	public int compareTo(Event e) {
		if(e instanceof FloatingTask) {
			return 1;
		} else if (e instanceof CalendarEvent) {
			CalendarEvent cal = (CalendarEvent)e;
			int result = this.getStartDateAndTime().compareTo(cal.getStartDateAndTime());
			if (result == 0) {
				result = this.getEndDateAndTime().compareTo(cal.getEndDateAndTime());
				if(result == 0) {
					result = this.getEventName().compareTo(cal.getEventName());
				}
			}
			return result;
		} else if (e instanceof ToDoEvent) {
			ToDoEvent todo = (ToDoEvent)e;
			int result = this.getStartDateAndTime().compareTo(todo.getDeadline());
			if (result == 0) {
				result = this.getEventName().compareTo(todo.getEventName());
			}
			return result;
		}
		return 0;
	}
	
	/*
	 * Checks if dates are valid for this date and time
	 * and if end is after start
	 */
	public static boolean areValidDates(DateTime start, DateTime end) {
		return (start.isBefore(end) && start.isAfterNow());
	}
	
	public void setDone(){
		//method stub for polymorthism
	}
	
```
###### src\easycheck\eventlist\CalendarEvent.java
``` java
	public boolean hasStopDate() {
		return stopDate != null;
	}
	
	public DateTime getStopDate() {
		return stopDate;
	}

	public void setStopDate(DateTime stopDate) {
		this.stopDate = stopDate;
	}

	public boolean isRepeating() {
		return repeating;
	}

	public void setRepeating(boolean repeating) {
		this.repeating = repeating;
	}

	public String getFrequency() {
		return frequency;
	}

	public void setFrequency(String frequency) {
		this.frequency = frequency;
	}
	
	public Event createCopy() {
		return new CalendarEvent(this);
	}
```
###### src\easycheck\eventlist\FloatingTask.java
``` java
 */

import java.io.IOException;
import java.io.StringWriter;
import java.util.LinkedHashMap;
import java.util.Map;

import org.json.simple.JSONObject;
import org.json.simple.JSONValue;

public class FloatingTask extends Event {
	private static final String JSON_TYPE = "type";
	private static final String JSON_EVENT_INDEX = "index";
	private static final String JSON_EVENT_NAME = "name";
	private static final String MESSAGE_JSON_STRING_ERROR = "Error in toJsonString method, most likely coding error";
	private static final String YELLOW = "@|yellow %s|@";
	private static final String GREEN = "@|green %s|@";
	
	private boolean complete;
	
	public FloatingTask() {}
	
	/**
	 * Event constructor
	 * @param eventIndex, the index of the event
	 * @param eventDesc, the description of the event
	 */
	public FloatingTask(int eventIndex, String eventName) {
		super(eventIndex, eventName);
		this.complete = false;
	}
	
	public FloatingTask(FloatingTask e) {
		this.setEventIndex(e.getEventIndex());
		this.setEventName(e.getEventName());
		this.complete = e.isDone();
	}
	
	public FloatingTask(JSONObject jsonObj){
		Long eventIndex = (Long) jsonObj.get(JSON_EVENT_INDEX);
		String eventName = (String) jsonObj.get(JSON_EVENT_NAME);
		this.setEventIndex(eventIndex.intValue());
		this.setEventName(eventName);
	}
	
	public void markComplete() {
		complete = true;
	}
	
	public void unMarkComplete() {
		complete = false;
	}
	
	public boolean isDone() {
		return complete;
	}
	
	/*
	 * (non-Javadoc)
	 * @see java.lang.Object#toString()
	 */
	@Override
	public String toString() {
		if(isDone()) {
			return String.format(GREEN, this.getEventIndex() + ". " + this.getEventName() + "\n");
		} else {
			return String.format(YELLOW, this.getEventIndex() + ". " + this.getEventName() + "\n");
		}
	}
	
	public String toPrintGroupString() {
		return this.toString();
	}
	
	@Override
	public boolean equals(Object obj) {
		return false;
	}
	
	@Override
	public int compareTo(Event e) {
		if(e instanceof FloatingTask) {
			return this.getEventName().compareTo(e.getEventName());
		} else if (e instanceof CalendarEvent) {
			return -1;
		} else if (e instanceof ToDoEvent) {
			return -1;
		}
		return 0;
	}
	
	
	public String toJsonString() {
		Map obj = new LinkedHashMap();
		obj.put(JSON_TYPE, "floating");
		obj.put(JSON_EVENT_INDEX, new Integer(this.getEventIndex()));
		obj.put(JSON_EVENT_NAME, this.getEventName());
		
		StringWriter out = new StringWriter();
	    try {
			JSONValue.writeJSONString(obj, out);
		} catch (IOException e) {
			System.out.println(MESSAGE_JSON_STRING_ERROR);
		}
	    return out.toString();
	}
	
	public Event createCopy() {
		return new FloatingTask(this);
	}
	
```
###### src\easycheck\integratedTest\IntegratedTest.java
``` java
    @Test
    public void testAddRepeatingEvent() {
        commandResponse = ui
                .executeCommand("add Christmas Party, 25 Dec 12:00 to 26 Dec 13:00 repeat yearly");
        assertEquals(
                "@|green Added|@ @|yellow 1. Christmas Party from Fri 25 Dec 2015 at 12:00 to Sat 26 Dec 2015 at 13:00 (Repeats yearly)|@\n\n",
                commandResponse);
    }
```
###### src\easycheck\integratedTest\IntegratedTest.java
``` java
    @Test
    public void testDisplayAll() {
    	ui.executeCommand("add plan party at on 25th Dec 12:00");
    	ui.executeCommand("add lunch at 1 pm 25th Dec to 2 pm 25th Dec");
    	ui.executeCommand("done plan");
    	commandResponse = ui.executeCommand("display all");
    	assertEquals(
                "@|cyan To Do:\n|@\n@|cyan Fri 25 Dec 2015:\n|@\t@|green 1. plan party due at 12:00 is complete|@\n\t@|yellow 2. lunch from 13:00 to 14:00|@\n\n",
                commandResponse);
    }
```
###### src\easycheck\integratedTest\IntegratedTest.java
``` java
    @Test
    public void testRepeatGoodFrequency() {
    	ui.executeCommand("add Plan Christmas Party at noon Dec 25th");
    	commandResponse = ui.executeCommand("repeat Plan Christmas Party, yearly");
    	assertEquals("@|green Successfully made Plan Christmas Party repeat yearly|@\n", commandResponse);
    }
    
    // test repeat with bad frequency
    @Test
    public void testRepeatBadFrequency() {
    	ui.executeCommand("add Plan Christmas Party at noon Dec 25th");
    	commandResponse = ui.executeCommand("repeat Plan Christmas Party, sdfsdf");
    	assertEquals("@|red Repeat: You have an invalid frequency.\n|@", commandResponse);
    }
    
    // test repeat with bad event name
    @Test
    public void testRepeatBadName() {
    	ui.executeCommand("add Plan Christmas Party at noon Dec 25th");
    	commandResponse = ui.executeCommand("repeat Plan Wrong Party, weekly");
    	assertEquals("@|red Repeat: There aren't any events with the name Plan Wrong Party|@\n", commandResponse);
    }
    
    // test repeat with incorrect index
    @Test
    public void testRepeatBadIndex() {
    	ui.executeCommand("add Plan Christmas Party at noon Dec 25th");
    	commandResponse = ui.executeCommand("repeat 2, weekly");
    	assertEquals("@|red Repeat: invalid event index 2.|@\n", commandResponse);
    }
```
###### src\easycheck\logicController\CommandExecutor.java
``` java
	 */
	public String executeCommand(Command command) {
		if (command instanceof Add) {
			redoStack.clear();
			return add((Add) command);
		} else if (command instanceof Repeat) { 
			redoStack.clear();
			return repeat((Repeat)command);
		} else if (command instanceof Display) {
			return display((Display) command);
		} else if (command instanceof Update) {
			redoStack.clear();
			return update((Update) command);
		} else if (command instanceof Delete) {
			redoStack.clear();
			return delete((Delete) command);
		} else if (command instanceof Markdone) {
			redoStack.clear();
			return markdone((Markdone) command);
		} else if (command instanceof Undo) {
			return undo((Undo) command);
		} else if (command instanceof Redo) {
			return redo((Redo) command);
		} else if (command instanceof Search) {
			return search((Search) command);
		} else if (command instanceof SaveAt) {
			return saveAt((SaveAt) command);
		} else if (command instanceof Exit) {
			return exit((Exit) command);
		} else if (command instanceof Invalid) {
			return Invalid((Invalid) command);
		} else if (command instanceof ReadFrom) {
			return readFrom((ReadFrom) command);
		} else {
			return command.toString();
		}
	}

	private String Invalid(Invalid command) {
		return command.toString();
	}

	/**
	 * Creates the correct type of event and adds it to eventList
	 * @return String with the action that took place
```
###### src\easycheck\logicController\CommandExecutor.java
``` java
	 */
	private String add(Add cmd) {
		assert(cmd.getTaskName() != null);

		String response = "";
		Event newEvent;
		// has arguments for a calendar event
		if (cmd.hasStart() && cmd.hasEnd()) {
			if (CalendarEvent.areValidDates(cmd.getStart(), cmd.getEnd())) {
				int eventIndex = eventList.size() + 1;
				if (cmd.isRepeating() && cmd.hasStopDate()) {
					if (CalendarEvent.areValidDates(cmd.getEnd(), cmd.getStopDate())) {
						newEvent = new CalendarEvent(eventIndex, cmd.getTaskName(), cmd.getStart(), 
								cmd.getEnd(), true, cmd.getFrequency(), cmd.getStopDate());
					} else {
						logger.log(Level.FINE, String.format(LOG_ADD_FAILED, cmd));
						return MESSAGE_INVALID_STOP_DATE;
					}
				} else if(cmd.isRepeating()) {
					newEvent = new CalendarEvent(eventIndex, cmd.getTaskName(), cmd.getStart(), 
							cmd.getEnd(), true, cmd.getFrequency());
				} else {
					newEvent = new CalendarEvent(eventIndex, cmd.getTaskName(), cmd.getStart(), cmd.getEnd());
				}
				undoStack.push(cloneEventList());
				logger.log(Level.FINE, String.format(LOG_ADDING, newEvent));
				eventList.add(newEvent);
				sort();
				response = String.format(MESSAGE_ADD_CMD_RESPONSE, newEvent);
			} else {
				logger.log(Level.FINE, String.format(LOG_ADD_FAILED, cmd));
				response = MESSAGE_INVALID_CALENDAR_DATES;
			}
			// has arguments for a to do event
		} else if (!cmd.hasStart() && cmd.hasEnd()) {
			if (ToDoEvent.isValidDate(cmd.getEnd())) {
				int eventIndex = eventList.size() + 1;
				if (cmd.isRepeating() && cmd.hasStopDate()) {
					if(cmd.getEnd().isBefore(cmd.getStopDate())) {
						newEvent = new ToDoEvent(eventIndex, cmd.getTaskName(), cmd.getEnd(), true, cmd.getFrequency(), cmd.getStopDate());
					} else {
						logger.log(Level.FINE, String.format(LOG_ADD_FAILED, cmd));
						return MESSAGE_INVALID_STOP_DATE;
					}
				} else if(cmd.isRepeating()) {
					newEvent = new ToDoEvent(eventIndex, cmd.getTaskName(), cmd.getEnd(), true, cmd.getFrequency());
				} else {
					newEvent = new ToDoEvent(eventIndex, cmd.getTaskName(), cmd.getEnd());
				}
				undoStack.push(cloneEventList());
				logger.log(Level.FINE, String.format(LOG_ADDING, newEvent));
				eventList.add(newEvent);
				sort();
				response = String.format(MESSAGE_ADD_CMD_RESPONSE, newEvent);
			} else {
				logger.log(Level.FINE, String.format(LOG_ADD_FAILED, cmd));
				response = MESSAGE_INVALID_TODO_DEADLINE;
			}
			// doesn't have time limits so it creates a floating task
		} else if (!cmd.hasStart() && !cmd.hasEnd()) {
			int eventIndex = eventList.size() + 1;
			newEvent = new FloatingTask(eventIndex, cmd.getTaskName());
			undoStack.push(cloneEventList());
			logger.log(Level.FINE, String.format(LOG_ADDING, newEvent));
			eventList.add(newEvent);
			sort();
			response = String.format(MESSAGE_ADD_CMD_RESPONSE, newEvent);

		}
		// response should have a response by this point
		assert(!response.equals(""));
		return response;
	}

	private void sort() {
		Collections.sort(eventList);
		reIndex();
	}

	/**
	 * Displays events according to flags set by user
	 * 
```
###### src\easycheck\logicController\CommandExecutor.java
``` java
	 */
	private String display(Display cmd) {
		String response = "";
		if(eventList.isEmpty()) {
			response = MESSAGE_DISPLAY_CMD_EMPTY;
		} else if (cmd.isIndex()) {
			response += eventList.get(cmd.getEventIndex() - 1);
		} else if (cmd.isFloating()) {
			response = getDisplayFloatingString();
		} else if (cmd.isDone()) {
			response = getDisplayDoneString();
		} else if (cmd.isDate()) {
			response = getDisplayDateString(cmd.getDisplayDate());
		} else if (cmd.isOverDue()) {
			response = getDisplayOverDueString();
		} else if (cmd.isAllFlag()) {
			response = getDisplayAllString();
		} else {
			response = getDefaultDisplayString();
		}
		// Response should not be empty
		assert(!response.equals(""));
		return response;
	}

	// Get Floating tasks for display string
```
###### src\easycheck\logicController\CommandExecutor.java
``` java
	private String getDisplayFloatingString() {
		String response = "";
		PrintGroup printGroup = new PrintGroup(PRINT_GROUP_HEADING_FLOATING);
		for (Event e : eventList) {
			if (e instanceof FloatingTask) {
				printGroup.addEntry(e);
			}
		}
		response = printGroup.toString();
		return response;
	}

	// Get the tasks on a specific date for the display command
```
###### src\easycheck\logicController\CommandExecutor.java
``` java
	private String getDisplayDateString(String dateText) {
		String response = "";
		PrintGroup dateGroup = new PrintGroup(dateText);
		for (Event e : eventList) {
			if (e instanceof CalendarEvent) {
				CalendarEvent cal = (CalendarEvent) e;
				if (dateGroup.getHeading().equals(cal.getStartDate())) {
					dateGroup.addEntry(cal);
				}
			} else if (e instanceof ToDoEvent && !e.isDone()) {
				ToDoEvent todo = (ToDoEvent) e;
				if (dateGroup.getHeading().equals(todo.getDeadlineDate())) {
					dateGroup.addEntry(todo);
				}
			}
		}

		response += dateGroup.toString();
		return response;
	}

	// Get done tasks for display string
```
###### src\easycheck\logicController\CommandExecutor.java
``` java
	private String getDisplayDoneString() {
		String response = "";
		PrintGroup floatingGroup = new PrintGroup(PRINT_GROUP_HEADING_FLOATING);
		ArrayList<PrintGroup> dateGroups = new ArrayList<PrintGroup>();
		for (Event e : eventList) {
			if (e instanceof FloatingTask && e.isDone()) {
				floatingGroup.addEntry(e);
			} else if (e instanceof CalendarEvent && e.isDone()) {
				boolean isAdded = false;
				CalendarEvent cal = (CalendarEvent) e;
				for (PrintGroup dateGroup : dateGroups) {
					if (dateGroup.getHeading().equals(cal.getStartDate())) {
						dateGroup.addEntry(cal);
						isAdded = true;
						break;
					}
				}

				if (!isAdded) {
					PrintGroup temp = new PrintGroup(cal.getStartDate());
					dateGroups.add(temp);
					temp.addEntry(cal);
				}
			} else if (e instanceof ToDoEvent && e.isDone()) {
				boolean isAdded = false;
				ToDoEvent todo = (ToDoEvent) e;
				for (PrintGroup dateGroup : dateGroups) {
					if (dateGroup.getHeading().equals(todo.getDeadlineDate())) {
						dateGroup.addEntry(todo);
						isAdded = true;
						break;
					}
				}

				if (!isAdded) {
					PrintGroup temp = new PrintGroup(todo.getDeadlineDate());
					dateGroups.add(temp);
					temp.addEntry(todo);
				}
			}
		}

		response += floatingGroup.toString();
		for (PrintGroup dateGroup : dateGroups) {
			response += dateGroup.toString();
		}
		return response;
	}

	private String getDisplayOverDueString() {
		String response = "";
		ArrayList<PrintGroup> dateGroups = new ArrayList<PrintGroup>();
		for (Event e : eventList) {
			if (e instanceof ToDoEvent) {
				ToDoEvent todo = (ToDoEvent) e;
				if (todo.isOverDue()) {
					boolean isAdded = false;
					for (PrintGroup dateGroup : dateGroups) {
						if (dateGroup.getHeading().equals(todo.getDeadlineDate())) {
							dateGroup.addEntry(todo);
							isAdded = true;
							break;
						}
					}

					if (!isAdded) {
						PrintGroup temp = new PrintGroup(todo.getDeadlineDate());
						dateGroups.add(temp);
						temp.addEntry(todo);
					}
				}
			}
		}

		for (PrintGroup dateGroup : dateGroups) {
			response += dateGroup.toString();
		}
		return response;
	}

	private String getDisplayAllString() {
		String response = "";
		PrintGroup floatingGroup = new PrintGroup(PRINT_GROUP_HEADING_FLOATING);
		ArrayList<PrintGroup> dateGroups = new ArrayList<PrintGroup>();
		for (Event e : eventList) {
			if (e instanceof FloatingTask) {
				floatingGroup.addEntry(e);
			} else if (e instanceof CalendarEvent) {
				boolean isAdded = false;
				CalendarEvent cal = (CalendarEvent) e;
				for (PrintGroup dateGroup : dateGroups) {
					if (dateGroup.getHeading().equals(cal.getStartDate())) {
						dateGroup.addEntry(cal);
						isAdded = true;
						break;
					}
				}

				if (!isAdded) {
					PrintGroup temp = new PrintGroup(cal.getStartDate());
					dateGroups.add(temp);
					temp.addEntry(cal);
				}
			} else if (e instanceof ToDoEvent) {
				boolean isAdded = false;
				ToDoEvent todo = (ToDoEvent) e;
				for (PrintGroup dateGroup : dateGroups) {
					if (dateGroup.getHeading().equals(todo.getDeadlineDate())) {
						dateGroup.addEntry(todo);
						isAdded = true;
						break;
					}
				}

				if (!isAdded) {
					PrintGroup temp = new PrintGroup(todo.getDeadlineDate());
					dateGroups.add(temp);
					temp.addEntry(todo);
				}
			}
		}

		response += floatingGroup.toString();
		for (PrintGroup dateGroup : dateGroups) {
			response += dateGroup.toString();
		}
		return response;
	}

	// Get the default text for display string
```
###### src\easycheck\logicController\CommandExecutor.java
``` java
	private String getDefaultDisplayString() {
		String response = "";
		PrintGroup floatingGroup = new PrintGroup(PRINT_GROUP_HEADING_FLOATING);
		ArrayList<PrintGroup> dateGroups = new ArrayList<PrintGroup>();
		for (Event e : eventList) {
			if (e instanceof FloatingTask && !e.isDone()) {
				floatingGroup.addEntry(e);
			} else if (e instanceof CalendarEvent && !e.isDone()) {
				boolean isAdded = false;
				CalendarEvent cal = (CalendarEvent) e;
				for (PrintGroup dateGroup : dateGroups) {
					if (dateGroup.getHeading().equals(cal.getStartDate())) {
						dateGroup.addEntry(cal);
						isAdded = true;
						break;
					}
				}

				if (!isAdded) {
					PrintGroup temp = new PrintGroup(cal.getStartDate());
					dateGroups.add(temp);
					temp.addEntry(cal);
				}
			} else if (e instanceof ToDoEvent && !e.isDone()) {
				boolean isAdded = false;
				ToDoEvent todo = (ToDoEvent) e;
				for (PrintGroup dateGroup : dateGroups) {
					if (dateGroup.getHeading().equals(todo.getDeadlineDate())) {
						dateGroup.addEntry(todo);
						isAdded = true;
						break;
					}
				}

				if (!isAdded) {
					PrintGroup temp = new PrintGroup(todo.getDeadlineDate());
					dateGroups.add(temp);
					temp.addEntry(todo);
				}
			}
		}

		response += floatingGroup.toString();
		for (PrintGroup dateGroup : dateGroups) {
			response += dateGroup.toString();
		}
		return response;
	}

	/*
```
###### src\easycheck\logicController\CommandExecutor.java
``` java
	public ArrayList<Event> cloneEventList() {
		ArrayList<Event> temp = new ArrayList<Event>();
		for (Event e : eventList) {
			temp.add(e.createCopy());
		}
		return temp;
	}


```
###### src\easycheck\logicController\CommandExecutor.java
``` java
	private String undo(Undo cmd) {
		if (undoStack.isEmpty()) {
			return MESSAGE_UNDO_EMPTY_STACK;
		} else {
			redoStack.push(cloneEventList());
			eventList = undoStack.pop();
		}
		Display disp = new Display();
		disp.setDefaultFlag(true);

		return display(disp);
	}

	// Executes an Redo command
```
###### src\easycheck\logicController\CommandExecutor.java
``` java
	private String redo(Redo cmd) {
		if (redoStack.isEmpty()) {
			return MESSAGE_REDO_EMPTY_STACK;
		} else {
			undoStack.push(cloneEventList());
			eventList = redoStack.pop();
		}

		Display disp = new Display();
		disp.setDefaultFlag(true);

		return display(disp);
	}

```
###### src\easycheck\logicController\CommandExecutor.java
``` java
	private String repeat(Repeat cmd) {
		int eventId;
		String eventName;
		Event e = null;
		
		if(isNumeric(cmd.getTask())) {
			eventId = Integer.parseInt(cmd.getTask());
			if(eventId < 1 || eventId > eventList.size()) {
				return String.format(MESSAGE_REPEAT_INVALID_INDEX, eventId);
			}
			e = eventList.get(eventId - 1);
			eventName = e.getEventName();
			undoStack.push(cloneEventList());
			if(cmd.getFrequency().equals("none")) {
				e.setRepeating(false);
				e.setFrequency(null);
				e.setStopDate(null);
				return String.format(MESSAGE_STOP_REPEAT_SUCCESS,
						eventName);
			} else {
				e.setRepeating(true);
				e.setFrequency(cmd.getFrequency());
				e.setStopDate(cmd.getEndDate());
				return String.format(MESSAGE_REPEAT_SUCCESS,
						eventName, e.getFrequency());
			}
		} else {
			eventName = cmd.getTask();
			for (Event temp: eventList) {
				if (temp.getEventName().toLowerCase().contains(eventName.toLowerCase())) {
					e = temp;
					break;
				}
			}
			if(e != null) {
				undoStack.push(cloneEventList());
				if(cmd.getFrequency().equals("none")) {
					e.setRepeating(false);
					e.setFrequency(null);
					e.setStopDate(null);
				} else {
					e.setRepeating(true);
					e.setFrequency(cmd.getFrequency());
					e.setStopDate(cmd.getEndDate());
				}
				return String.format(MESSAGE_REPEAT_SUCCESS,
						eventName, e.getFrequency());
			} else {
				return String.format(MESSAGE_REPEAT_INVALID_EVENT_NAME, eventName);
			}
		}
	}

	private String exit(Exit cmd) {
		AnsiConsole.systemUninstall();
		System.exit(1);
		return EMPTY_STRING;
	}

	public ArrayList<Event> getEventList() {
		return eventList;
	}

```
###### src\easycheck\logicController\PrintGroup.java
``` java
 */

import java.util.ArrayList;

import static org.fusesource.jansi.Ansi.*;
import static org.fusesource.jansi.Ansi.Color.*;

import easycheck.eventlist.Event;

public class PrintGroup {
	public static final String NEWLINE = "\n";
	public static final String TAB = "\t";
	public static final String COLON = ":";
	public static final String HEADING_COLOR = "@|cyan %s|@";
	
	private String heading;
	private ArrayList<Event> eventList;
	
	public PrintGroup(String heading) {
		this.heading = heading;
		eventList = new ArrayList<Event>();
	}
	
	public void addEntry(Event e) {
		eventList.add(e);
	}
	
	
	public String getHeading() {
		return heading;
	}

	public void setHeading(String heading) {
		this.heading = heading;
	}

	public String toString() {
		String printGroup = String.format(HEADING_COLOR, heading + COLON + NEWLINE);
		for(Event e: eventList) {
			printGroup += TAB + e.toPrintGroupString();
		}
		return printGroup + NEWLINE;
	}
}
```
###### src\easycheck\storage\StorageManager.java
``` java
 * 
 */
public class StorageManager {
	private static final String EVENT_TYPE_CALENDAR_KEY = "calendar";
	private static final String EVENT_TYPE_TODO_KEY = "todo";
	private static final String EVENT_TYPE_BASE_KEY = "floating";
	private static final String JSON_TYPE = "type";
	private static final String ERROR_IN_CREATING_FILE = "@|red Your file might have been moved@ \n";
	
	
	private File easyCheckFile;
```
