# A0145668R
###### src\easycheck\commandParser\CommandParser.java
``` java
    private String[] getDisplayArguments(String commandArguments) {
        // split arguments and then trim them.
        String[] arguments = trimArguments(commandArguments
                .split(ARGUMENT_SPLITTER));
        return arguments;
    }

```
###### src\easycheck\commandParser\CommandParser.java
``` java
    private Command createDisplayCommand(String[] arguments) {
        Display disp = new Display();
        try {
            if (arguments == null) {
                disp.setDefaultFlag(true);
            } else if (arguments.length == 1) {
                if (arguments[0].equals(DISPLAY_FLAG_FLOATING)) {
                    disp.setFloatingFlag(true);
                } else if (arguments[0].equals(DISPLAY_FLAG_OVER_DUE)) {
                    disp.setOverDueFlag(true);
                } else if (arguments[0].equals(DISPLAY_FLAG_DONE)) {
                    disp.setDoneFlag(true);
                } else {
                    return new Invalid(String.format(
                            MESSAGE_INVALID_DISPLAY_ARGS, arguments[0]));
                }
            } else if (arguments.length == 2) {
                if (arguments[0].equals(DISPLAY_FLAG_DATE)) {
                    DateTime displayDate = parseDateText(arguments[1])[FIRST_PARSED_DATE_TEXT];
                    if (displayDate != null) {
                        disp.setDateFlag(true);
                        disp.setDisplayDate(displayDate);
                    } else {
                        return new Invalid(String.format(
                                MESSAGE_INVALID_DISPLAY_DATE, arguments[1]));
                    }
                } else if (arguments[0].equals(DISPLAY_FLAG_INDEX)) {
                    try {
                        int eventIndex = Integer.parseInt(arguments[1]);
                        disp.setEventIndex(eventIndex);
                        disp.setIndexFlag(true);
                    } catch (NumberFormatException e) {
                        return new Invalid(String.format(
                                MESSAGE_INVALID_DISPLAY_INDEX, arguments[1]));
                    }
                } else {
                    return new Invalid(String.format(
                            MESSAGE_INVALID_DISPLAY_ARGS, arguments[0]));
                }
            } else {
                return new Invalid(MESSAGE_INVALID_DISPLAY_NUM_OF_ARGS);
            }
        } catch (Exception e) {
            return new Invalid(MESSAGE_INVALID_DISPLAY_NUM_OF_ARGS);
        }
        return disp;
    }

```
###### src\easycheck\commandParser\CommandParser.java
``` java
    public DateTime[] parseDateText(String dateString) throws Exception {
        isValidExplicitDate(dateString);
        Parser dateParser = new Parser();
        DateTime[] parsedDates;
        List<DateGroup> dateGroups = dateParser.parse(dateString);
        if (dateGroups.size() == 1) {
            DateGroup dateGroup = dateGroups.get(0);
            if (dateGroup.getDates().size() == 1) {
                parsedDates = new DateTime[DATE_GROUP_ONE_DATE];
                parsedDates[0] = new DateTime(dateGroup.getDates().get(0));
            } else if (dateGroup.getDates().size() == 2) {
                parsedDates = new DateTime[DATE_GROUP_TWO_DATES];
                parsedDates[0] = new DateTime(dateGroup.getDates().get(0));
                parsedDates[1] = new DateTime(dateGroup.getDates().get(1));
            } else {
                parsedDates = new DateTime[DATE_GROUP_ONE_DATE];
                parsedDates[0] = null;
            }

        } else {
            parsedDates = new DateTime[DATE_GROUP_ONE_DATE];
            parsedDates[0] = null;
        }
        return parsedDates;
    }

    private String[] getArguments(String commandArguments, int expectedArguments)
            throws Exception {
        // split arguments and then trim them.
        String[] arguments = trimArguments(commandArguments
                .split(ARGUMENT_SPLITTER));
        if (arguments.length < expectedArguments
                || arguments.length > expectedArguments) {
            throw new Exception();
        }
        return arguments;
    }

    // removes leading and trailing whitespace from arguments
    private String[] trimArguments(String[] arguments) {
        String[] trimmedArguments = new String[arguments.length];
        for (int i = 0; i < arguments.length; i++) {
            trimmedArguments[i] = arguments[i].trim();
        }
        return trimmedArguments;
    }

    // replaces the flexi keywords with ',' for parsing.
    private String[] checkFlexi(String commandArguments) {
        for (int i = 0; i < FLEXI_KEYWORDS.length; i++) {
            commandArguments = commandArguments.replace(FLEXI_KEYWORDS[i],
                    ARGUMENT_SPLITTER);
        }
        return commandArguments.split(ARGUMENT_SPLITTER);
    }

    // checks if explicit dates (MM/dd/yyyy and MM/dd/yyyy HH:mm) are valid.
    private boolean isValidExplicitDate(String dateString) throws Exception {
        dateString = dateString.replace(DATE_SPLITTER_SLASH, DATE_SPLITTER_DOT);
        if (!dateString.contains(DATE_SPLITTER_DOT)) {
            // is not an explicit date
            return true;
        }
        // check if date has time and if there is exactly one date
        if (dateString.contains(DATE_SPLITTER_COLON)
                && (dateString.length() <= NUM_CHAR_DATE_TIME_INPUT)) {
            timeFormatter.parseDateTime(dateString);
        } else if (dateString.length() <= NUM_CHAR_DATE_INPUT) {
            timeFormatter.parseDateTime(dateString + DUMMY_TIME);
        } else {
            // there is more than 1 date (should be 2)
            String[] dateStringArray = splitDates(dateString);
            if (dateStringArray.length != 2) {
                throw new Exception();
            } else {
                isValidExplicitDate(dateStringArray[FIRST_PARSED_DATE_TEXT]);
                isValidExplicitDate(dateStringArray[SECOND_PARSED_DATE_TEXT]);
            }
        }
        return true;
    }
    
    // splits and trims date strings in the form of "date to date"
    private String[] splitDates(String dateString) {
        String[] dateStrings = trimArguments(dateString
                .split(FLEXI_KEYWORD_EVENT_SPLITTER));
        return dateStrings;
    }
    
```
###### src\easycheck\logicController\CommandExecutor.java
``` java
	 */
	public String executeCommand(Command command) {
		if (command instanceof Add) {
			return add((Add) command);
		} else if (command instanceof Display) {
			return display((Display) command);
		} else if (command instanceof Update) {
			return update((Update) command);
		} else if (command instanceof Delete) {
			return delete((Delete) command);
		} else if (command instanceof Markdone) {
			return markdone((Markdone) command);
		} else if (command instanceof Undo) {
			return undo((Undo) command);
		} else if (command instanceof Redo) {
			return redo((Redo) command);
		} else if (command instanceof Search) {
			return search((Search) command);
		} else if (command instanceof SaveAt) {
			return saveAt((SaveAt) command);
		} else if (command instanceof Exit) {
			return exit((Exit) command);
		} else if (command instanceof Invalid) {
			return Invalid((Invalid) command);
		} else if (command instanceof ReadFrom) {
			return readFrom((ReadFrom) command);
		} else {
			return command.toString();
		}
	}

	private String Invalid(Invalid command) {
		return command.toString();
	}

	/**
	 * Creates the correct type of event and adds it to eventList
	 * 
```
###### src\easycheck\logicController\CommandExecutor.java
``` java
	 */
	private String add(Add cmd) {
		assert(cmd.getTaskName() != null);

		String response = "";
		Event newEvent;
		// has arguments for a calendar event
		if (cmd.hasStart() && cmd.hasEnd()) {
			if (CalendarEvent.areValidDates(cmd.getStart(), cmd.getEnd())) {
				int eventIndex = eventList.size() + 1;
				if (cmd.isRepeating() && cmd.hasStopDate()) {
					newEvent = new CalendarEvent(eventIndex, cmd.getTaskName(), cmd.getStart(), 
							cmd.getEnd(), true, cmd.getFrequency(), cmd.getStopDate());
				} else if(cmd.isRepeating()) {
					newEvent = new CalendarEvent(eventIndex, cmd.getTaskName(), cmd.getStart(), 
							cmd.getEnd(), true, cmd.getFrequency());
				} else {
					newEvent = new CalendarEvent(eventIndex, cmd.getTaskName(), cmd.getStart(), 
							cmd.getEnd());
				}
				undoStack.push(cloneEventList());
				eventList.add(newEvent);
				sort();
				response = String.format(MESSAGE_ADD_CMD_RESPONSE, newEvent);
			} else {
				response = MESSAGE_INVALID_CALENDAR_DATES;
			}
			// has arguments for a to do event
		} else if (!cmd.hasStart() && cmd.hasEnd()) {
			if (ToDoEvent.isValidDate(cmd.getEnd())) {
				int eventIndex = eventList.size() + 1;
				if (cmd.isRepeating() && cmd.hasStopDate()) {
					newEvent = new ToDoEvent(eventIndex, cmd.getTaskName(), cmd.getEnd(), true, cmd.getFrequency(), cmd.getStopDate());
				} else if(cmd.isRepeating()) {
					newEvent = new ToDoEvent(eventIndex, cmd.getTaskName(), cmd.getEnd(), true, cmd.getFrequency());
				} else {
					newEvent = new ToDoEvent(eventIndex, cmd.getTaskName(), cmd.getEnd());
				}
				undoStack.push(cloneEventList());
				eventList.add(newEvent);
				sort();
				response = String.format(MESSAGE_ADD_CMD_RESPONSE, newEvent);
			} else {
				response = MESSAGE_INVALID_TODO_DEADLINE;
			}
			// doesn't have time limits so it creates a floating task
		} else if (!cmd.hasStart() && !cmd.hasEnd()) {
			int eventIndex = eventList.size() + 1;
			newEvent = new FloatingTask(eventIndex, cmd.getTaskName());
			undoStack.push(cloneEventList());
			eventList.add(newEvent);
			sort();
			response = String.format(MESSAGE_ADD_CMD_RESPONSE, newEvent);

		}
		// response should have a response by this point
		assert(!response.equals(""));
		return response;
	}

	private void sort() {
		Collections.sort(eventList);
		reIndex();
	}

	/**
	 * Displays all events
	 * 
```
###### src\easycheck\logicController\CommandExecutor.java
``` java
	 */
	private String display(Display cmd) {
		String response = "";
		if (cmd.isIndex()) {
			response += eventList.get(cmd.getEventIndex() - 1);
		} else if (cmd.isFloating()) {
			response = getDisplayFloatingString();
		} else if (cmd.isDone()) {
			response = getDisplayDoneString();
		} else if (cmd.isDate()) {
			response = getDisplayDateString(cmd.getDisplayDate());
		} else if (cmd.isOverDue()) {
			response = getDisplayOverDueString();
		} else {
			response = getDefaultDisplayString();
		}
		// Response should not be empty
		assert(!response.equals(""));
		return response;
	}

	// Get Floating tasks for display string
	// @author A0145668R
	private String getDisplayFloatingString() {
		String response = "";
		PrintGroup printGroup = new PrintGroup(PRINT_GROUP_HEADING_FLOATING);
		for (Event e : eventList) {
			if (e instanceof FloatingTask) {
				printGroup.addEntry(e);
			}
		}
		response = printGroup.toString();
		return response;
	}
	
	// Get the tasks on a specific date for the display command
	// @author A0145668R
	private String getDisplayDateString(String dateText) {
		String response = "";
		PrintGroup dateGroup = new PrintGroup(dateText);
		for (Event e : eventList) {
			if (e instanceof CalendarEvent) {
				CalendarEvent cal = (CalendarEvent) e;
				if (dateGroup.getHeading().equals(cal.getStartDate())) {
					dateGroup.addEntry(cal);
				}
			} else if (e instanceof ToDoEvent && !e.isDone()) {
				ToDoEvent todo = (ToDoEvent) e;
				if (dateGroup.getHeading().equals(todo.getDeadlineDate())) {
					dateGroup.addEntry(todo);
				}
			}
		}

		response += dateGroup.toString();
		return response;
	}
	
	// Get done tasks for display string
	// @author A0145668R
	private String getDisplayDoneString() {
		String response = "";
		PrintGroup floatingGroup = new PrintGroup(PRINT_GROUP_HEADING_FLOATING);
		ArrayList<PrintGroup> dateGroups = new ArrayList<PrintGroup>();
		for (Event e : eventList) {
			if (e instanceof FloatingTask && e.isDone()) {
				floatingGroup.addEntry(e);
			} else if (e instanceof CalendarEvent && e.isDone()) {
				boolean isAdded = false;
				CalendarEvent cal = (CalendarEvent) e;
				for (PrintGroup dateGroup : dateGroups) {
					if (dateGroup.getHeading().equals(cal.getStartDate())) {
						dateGroup.addEntry(cal);
						isAdded = true;
						break;
					}
				}

				if (!isAdded) {
					PrintGroup temp = new PrintGroup(cal.getStartDate());
					dateGroups.add(temp);
					temp.addEntry(cal);
				}
			} else if (e instanceof ToDoEvent && e.isDone()) {
				boolean isAdded = false;
				ToDoEvent todo = (ToDoEvent) e;
				for (PrintGroup dateGroup : dateGroups) {
					if (dateGroup.getHeading().equals(todo.getDeadlineDate())) {
						dateGroup.addEntry(todo);
						isAdded = true;
						break;
					}
				}

				if (!isAdded) {
					PrintGroup temp = new PrintGroup(todo.getDeadlineDate());
					dateGroups.add(temp);
					temp.addEntry(todo);
				}
			}
		}

		response += floatingGroup.toString();
		for (PrintGroup dateGroup : dateGroups) {
			response += dateGroup.toString();
		}
		return response;
	}
	
	private String getDisplayOverDueString() {
		String response = "";
		ArrayList<PrintGroup> dateGroups = new ArrayList<PrintGroup>();
		for (Event e : eventList) {
			if (e instanceof ToDoEvent) {
				ToDoEvent todo = (ToDoEvent) e;
				if (todo.isOverDue()) {
					boolean isAdded = false;
					for (PrintGroup dateGroup : dateGroups) {
						if (dateGroup.getHeading().equals(todo.getDeadlineDate())) {
							dateGroup.addEntry(todo);
							isAdded = true;
							break;
						}
					}
	
					if (!isAdded) {
						PrintGroup temp = new PrintGroup(todo.getDeadlineDate());
						dateGroups.add(temp);
						temp.addEntry(todo);
					}
				}
			}
		}

		for (PrintGroup dateGroup : dateGroups) {
			response += dateGroup.toString();
		}
		return response;
	}
	
	// Get the default text for display string
	// @author A0145668R
	private String getDefaultDisplayString() {
		String response = "";
		PrintGroup floatingGroup = new PrintGroup(PRINT_GROUP_HEADING_FLOATING);
		ArrayList<PrintGroup> dateGroups = new ArrayList<PrintGroup>();
		for (Event e : eventList) {
			if (e instanceof FloatingTask && !e.isDone()) {
				floatingGroup.addEntry(e);
			} else if (e instanceof CalendarEvent && !e.isDone()) {
				boolean isAdded = false;
				CalendarEvent cal = (CalendarEvent) e;
				for (PrintGroup dateGroup : dateGroups) {
					if (dateGroup.getHeading().equals(cal.getStartDate())) {
						dateGroup.addEntry(cal);
						isAdded = true;
						break;
					}
				}

				if (!isAdded) {
					PrintGroup temp = new PrintGroup(cal.getStartDate());
					dateGroups.add(temp);
					temp.addEntry(cal);
				}
			} else if (e instanceof ToDoEvent && !e.isDone()) {
				boolean isAdded = false;
				ToDoEvent todo = (ToDoEvent) e;
				for (PrintGroup dateGroup : dateGroups) {
					if (dateGroup.getHeading().equals(todo.getDeadlineDate())) {
						dateGroup.addEntry(todo);
						isAdded = true;
						break;
					}
				}

				if (!isAdded) {
					PrintGroup temp = new PrintGroup(todo.getDeadlineDate());
					dateGroups.add(temp);
					temp.addEntry(todo);
				}
			}
		}

		response += floatingGroup.toString();
		for (PrintGroup dateGroup : dateGroups) {
			response += dateGroup.toString();
		}
		return response;
	}

	/*
```
